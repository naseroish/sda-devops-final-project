name: ArgoCD Setup

on:
  workflow_dispatch:
    inputs:
      cloud_provider:
        description: 'Cloud Provider'
        required: true
        type: choice
        options:
          - digitalocean
          - azure
          - aws
          - gcp
        default: 'digitalocean'
      action:
        description: 'Action to perform'
        required: true
        default: 'install'
        type: choice
        options:
          - install
          - uninstall

env:
  ARGOCD_VERSION: v3.1.9
  ARGOCD_NAMESPACE: argocd

jobs:
  setup-argocd:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # ==================== DigitalOcean Setup ====================
      - name: Setup DigitalOcean CLI
        if: github.event.inputs.cloud_provider == 'digitalocean'
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_TOKEN }}

      - name: Get DOKS credentials
        if: github.event.inputs.cloud_provider == 'digitalocean'
        run: |
          doctl kubernetes cluster kubeconfig save ${{ secrets.DOKS_CLUSTER_NAME }}

      # ==================== Azure Setup ====================
      - name: Azure Login
        if: github.event.inputs.cloud_provider == 'azure'
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS credentials
        if: github.event.inputs.cloud_provider == 'azure'
        run: |
          az aks get-credentials \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      # ==================== AWS Setup ====================
      - name: Configure AWS Credentials
        if: github.event.inputs.cloud_provider == 'aws'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Get EKS credentials
        if: github.event.inputs.cloud_provider == 'aws'
        run: |
          aws eks update-kubeconfig --name ${{ secrets.EKS_CLUSTER_NAME }} --region ${{ secrets.AWS_REGION }}

      # ==================== GCP Setup ====================
      - name: Authenticate to Google Cloud
        if: github.event.inputs.cloud_provider == 'gcp'
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Get GKE credentials
        if: github.event.inputs.cloud_provider == 'gcp'
        uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: ${{ secrets.GKE_CLUSTER_NAME }}
          location: ${{ secrets.GCP_REGION }}

      # ==================== Verify Cluster ====================
      - name: Verify cluster connectivity
        run: |
          echo "Connected to ${{ github.event.inputs.cloud_provider }} Kubernetes cluster"
          kubectl cluster-info
          kubectl get nodes

      - name: Create required namespaces
        run: |
          kubectl create namespace $ARGOCD_NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
          kubectl create namespace expensy --dry-run=client -o yaml | kubectl apply -f -
          kubectl create namespace monitoring --dry-run=client -o yaml | kubectl apply -f -
          kubectl create namespace ingress-nginx --dry-run=client -o yaml | kubectl apply -f -

      - name: Create application secrets
        run: |
          kubectl -n expensy create secret generic expensy-secrets \
            --from-literal=DATABASE_URI='${{ secrets.DATABASE_URI }}' \
            --from-literal=REDIS_PASSWORD='${{ secrets.REDIS_PASSWORD }}' \
            --from-literal=MONGO_INITDB_ROOT_USERNAME='${{ secrets.MONGO_INITDB_ROOT_USERNAME }}' \
            --from-literal=MONGO_INITDB_ROOT_PASSWORD='${{ secrets.MONGO_INITDB_ROOT_PASSWORD }}' \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Check if ArgoCD is installed
        id: check-argocd
        run: |
          if kubectl get deployment argocd-server -n $ARGOCD_NAMESPACE >/dev/null 2>&1; then
            echo "installed=true" >> $GITHUB_OUTPUT
          else
            echo "installed=false" >> $GITHUB_OUTPUT
          fi

      - name: Install ArgoCD
        if: steps.check-argocd.outputs.installed == 'false' && github.event.inputs.action == 'install'
        run: |
          echo "Installing ArgoCD $ARGOCD_VERSION..."
          kubectl apply -n $ARGOCD_NAMESPACE -f https://raw.githubusercontent.com/argoproj/argo-cd/$ARGOCD_VERSION/manifests/install.yaml
          
          echo "Waiting for ArgoCD to be ready..."
          kubectl wait --for=condition=available deployment/argocd-server -n $ARGOCD_NAMESPACE --timeout=600s
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-server -n $ARGOCD_NAMESPACE --timeout=600s

      - name: Install ArgoCD CLI
        if: github.event.inputs.action == 'install'
        run: |
          echo "Installing ArgoCD CLI..."
          curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/$ARGOCD_VERSION/argocd-linux-amd64
          sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
          rm argocd-linux-amd64
          argocd version --client

      - name: Setup ArgoCD port-forward and login
        if: github.event.inputs.action == 'install'
        id: argocd-login
        run: |
          echo "Setting up port-forward to ArgoCD server..."
          kubectl port-forward svc/argocd-server -n $ARGOCD_NAMESPACE 8080:443 >/dev/null 2>&1 &
          echo "portforward_pid=$!" >> $GITHUB_OUTPUT
          
          # Wait for port-forward to be ready
          for i in {1..20}; do
            if curl -sk https://localhost:8080 >/dev/null 2>&1; then
              echo "Port-forward is ready"
              break
            fi
            echo "Waiting for port-forward... ($i/20)"
            sleep 3
          done
          
          # Get initial admin password
          PASSWORD=$(kubectl -n $ARGOCD_NAMESPACE get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          echo "::add-mask::$PASSWORD"
          
          # Login to ArgoCD
          echo "Logging in to ArgoCD..."
          for i in {1..10}; do
            if argocd login localhost:8080 --username admin --password "$PASSWORD" --insecure; then
              echo "Successfully logged in to ArgoCD"
              break
            fi
            echo "Retrying ArgoCD login ($i/10)..."
            sleep 5
          done

      - name: Configure private GitHub repository in ArgoCD
        if: github.event.inputs.action == 'install'
        run: |
          echo "Configuring private repository access..."
          argocd repo add https://github.com/${{ github.repository }}.git \
            --username ${{ github.actor }} \
            --password ${{ secrets.GH_PAT }} \
            --insecure-skip-server-verification
          
          echo "‚úÖ Repository configured successfully"
          argocd repo list

      - name: Configure ArgoCD to manage applications
        if: github.event.inputs.action == 'install'
        run: |
          echo "Applying ArgoCD root application (App of Apps pattern)..."
          kubectl apply -f kubernetes/argocd.yaml
          
          echo "Waiting for ArgoCD to discover all applications..."
          sleep 10
          
          echo "‚úÖ ArgoCD is now managing all applications!"
          echo ""
          echo "ArgoCD will automatically discover and deploy:"
          echo "  ‚úÖ Expensy app (frontend, backend, MongoDB, Redis)"
          echo "  ‚úÖ Prometheus stack (Prometheus, Alertmanager, Node Exporter)"
          echo "  ‚úÖ Grafana with pre-configured datasources"
          echo "  ‚úÖ Loki for log aggregation with Promtail"
          echo "  ‚úÖ Elasticsearch for log storage"
          echo "  ‚úÖ NGINX Ingress Controller"
          echo "  ‚úÖ cert-manager for SSL certificates"
          echo "  ‚úÖ ArgoCD UI with LoadBalancer"
          echo ""
          echo "ArgoCD features enabled:"
          echo "  üîÑ Auto-sync: Changes from Git are automatically deployed"
          echo "  üîß Self-heal: Manual changes are automatically reverted"
          echo "  üóëÔ∏è  Auto-prune: Deleted resources in Git are removed from cluster"
          echo ""
          echo "All application manifests in kubernetes/ folder are managed by ArgoCD!"

      - name: Get ArgoCD admin password
        if: steps.check-argocd.outputs.installed == 'false' && github.event.inputs.action == 'install'
        run: |
          echo "Getting ArgoCD admin password..."
          PASSWORD=$(kubectl -n $ARGOCD_NAMESPACE get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          echo "::add-mask::$PASSWORD"
          echo "ARGOCD_PASSWORD=$PASSWORD" >> $GITHUB_ENV
          echo ""
          echo "=========================================="
          echo "ArgoCD Setup Complete!"
          echo "=========================================="
          echo "Username: admin"
          echo "Password: (stored in argocd-initial-admin-secret)"
          echo ""
          echo "‚ö†Ô∏è  IMPORTANT: DNS Configuration Required"
          echo "=========================================="
          echo "The following services are exposed via LoadBalancer with Azure DNS labels:"
          echo ""
          echo "1. ArgoCD UI:"
          echo "   - Azure DNS: argocd-naseroish.<region>.cloudapp.azure.com"
          echo "   - Configure Cloudflare CNAME: argocd.naseroish.com ‚Üí argocd-naseroish.<region>.cloudapp.azure.com"
          echo ""
          echo "2. Grafana:"
          echo "   - Azure DNS: grafana-naseroish.<region>.cloudapp.azure.com"
          echo "   - Configure Cloudflare CNAME: grafana.naseroish.com ‚Üí grafana-naseroish.<region>.cloudapp.azure.com"
          echo ""
          echo "3. Expensy App (via NGINX Ingress):"
          echo "   - Your existing final.naseroish.com setup remains unchanged"
          echo ""
          echo "To get the actual Azure DNS names and IPs, run:"
          echo "  kubectl get svc -n argocd argocd-ui-argo-cd-argocd-server -o wide"
          echo "  kubectl get svc -n monitoring grafana -o wide"
          echo "  kubectl get svc -n ingress-nginx ingress-nginx-controller -o wide"
          echo ""
          echo "Benefits of this architecture:"
          echo "  ‚úÖ Clean separation of concerns"
          echo "  ‚úÖ No subpath routing issues"
          echo "  ‚úÖ Better security isolation"
          echo "  ‚úÖ Independent scaling per service"
          echo "  ‚úÖ Easier SSL/TLS management with Cloudflare"

      - name: Cleanup port-forward
        if: always() && github.event.inputs.action == 'install'
        run: |
          if [ -n "${{ steps.argocd-login.outputs.portforward_pid }}" ]; then
            kill ${{ steps.argocd-login.outputs.portforward_pid }} 2>/dev/null || true
          fi

      - name: Uninstall ArgoCD
        if: github.event.inputs.action == 'uninstall'
        run: |
          echo "Removing all ArgoCD managed applications..."
          kubectl delete -f kubernetes/argocd.yaml --ignore-not-found=true
          
          echo "Waiting for all applications to be removed..."
          sleep 30
          
          echo "Uninstalling ArgoCD..."
          kubectl delete -n $ARGOCD_NAMESPACE -f https://raw.githubusercontent.com/argoproj/argo-cd/$ARGOCD_VERSION/manifests/install.yaml --ignore-not-found=true
          
          echo "Removing ArgoCD namespace..."
          kubectl delete namespace $ARGOCD_NAMESPACE --ignore-not-found=true
          
          echo "‚úÖ ArgoCD has been uninstalled and all managed applications removed"

